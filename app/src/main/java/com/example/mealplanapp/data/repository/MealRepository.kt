package com.example.mealplanapp.data.repository

// Removed import com.example.mealplanapp.data.entity.MealEntity
// Removed import com.example.mealplanapp.data.entity.MealPlanWithMeals
// Removed unused flow operators like flatMapConcat, flow, first etc. for the deleted function
import android.content.Context
import android.util.Log
import com.example.mealplanapp.data.dao.MealPlanDao
import com.example.mealplanapp.data.entity.Meal
import com.example.mealplanapp.data.entity.SavedMealPlan
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import java.io.BufferedReader
import java.io.InputStreamReader
import javax.inject.Inject


class MealRepository constructor(
    private val mealPlanDao: MealPlanDao, // Use the correct DAO
    private val appContext: Context
) {

    // This function now creates Meal objects directly
    suspend fun loadMealsFromCSV(): List<Meal> = // Return List<Meal>
        withContext(Dispatchers.IO) {
            val meals = mutableListOf<Meal>() // Create List<Meal>

            try {
                Log.d("CSVLoading", "Attempting to open CSV file")
                appContext.assets.open("meal_plan.csv").use { inputStream ->
                    BufferedReader(InputStreamReader(inputStream)).use { reader ->
                        reader.readLine() // Skip header
                        Log.d("CSVLoading", "CSV header skipped")

                        reader.forEachLine { line ->
                            // Basic CSV parsing, consider a robust library for complex CSVs
                            val parts = line.split(",(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)".toRegex())
                                .map { it.trim().removeSurrounding("\"") }

                            if (parts.size >= 4) { // Ensure enough parts exist
                                val category = parts[2] // Assuming index 2 is category
                                val title = parts[1]    // Assuming index 1 is title/name
                                // Assuming index 3 is a comma-separated list of ingredients
                                val ingredients = parts[3].split(',').map { it.trim() }.filter { it.isNotEmpty() }

                                // Create a Meal object
                                val meal = Meal(
                                    // id will be auto-generated by Room on insert
                                    name = title,
                                    // You might want a default image or fetch based on name/category
                                    imageResId = 0, // Placeholder: Consider how to map images
                                    description = parts.getOrElse(4) { "" }, // Add description if available
                                    category = category,
                                    calories = parts.getOrElse(5) { "0" }.toIntOrNull() ?: 0, // Add calories if available
                                    ingredients = ingredients,
                                    instructions = parts.getOrElse(6) { "" } // Add instructions if available
                                )
                                meals.add(meal)
                            } else {
                                Log.w("CSVLoading", "Skipping invalid line: $line")
                            }
                        }
                        Log.d("CSVLoading", "Processed lines")
                    }
                }
                Log.d("CSVLoading", "Parsed ${meals.size} meals from CSV")
            } catch (e: Exception) {
                Log.e("CSVLoading", "Error loading CSV", e)
            }

            return@withContext meals
        }

    // --- Pass-through functions to DAO ---

    suspend fun insertMeal(meal: Meal) {
        mealPlanDao.insertMeal(meal)
    }

    suspend fun insertMeals(meals: List<Meal>) {
        // Consider making insertMeals suspend in DAO for bulk insert efficiency if needed
        // mealPlanDao.insertMeals(meals) // If you have a bulk insert in DAO
        // Otherwise, keep the loop (though less efficient for large lists)
        meals.forEach { meal ->
            mealPlanDao.insertMeal(meal) // Uses the single insert method
        }
    }

    suspend fun insertSavedMealPlan(savedMealPlan: SavedMealPlan) {
        mealPlanDao.insertSavedMealPlan(savedMealPlan)
    }

    suspend fun deleteSavedMealPlan(mealPlan: SavedMealPlan) {
        mealPlanDao.deleteSavedMealPlan(mealPlan)
    }

    // This complex mapping function is REMOVED.
    // The ViewModel now handles combining SavedMealPlan with Meal details.
    /*
    @OptIn(ExperimentalCoroutinesApi::class)
    fun getAllSavedMealPlans(): Flow<List<MealPlanWithMeals>> = mealPlanDao.getAllSavedMealPlans().flatMapConcat { savedMealPlans ->
        flow {
            val mealPlansWithMeals = savedMealPlans.map { mealPlan ->
                mealPlanDao.getMealPlanWithMeals(mealPlan.id) // THIS METHOD IS GONE
            }.map { it.first() } // This logic was flawed anyway
            emit(mealPlansWithMeals)
        }
    }
    */

    // get meal by name - Passthrough
    suspend fun getMealByName(name: String): Meal? {
        return mealPlanDao.getMealByName(name)
    }

    // save meal plan - Passthrough (redundant, same as insertSavedMealPlan)
    // You can likely remove this if `insertSavedMealPlan` is used everywhere
    // suspend fun saveMealPlan(mealPlan: SavedMealPlan) {
    //     mealPlanDao.insertSavedMealPlan(mealPlan)
    // }

    // getAllMeals - Passthrough
    fun getAllMeals(): Flow<List<Meal>> {
        return mealPlanDao.getAllMeals()
    }

    // Optional: Add if used by ViewModel
    suspend fun getMealCount(): Int {
        // Assumes you add getMealCount() to your MealPlanDao
        // return mealPlanDao.getMealCount()
        // Alternatively, fetch all and count (less efficient)
        val meals = mealPlanDao.getAllMeals().first() // Get the first emission (current list)
        return meals.size
    }

    // Optional: Add if needed by ViewModel
    suspend fun getSavedMealPlanCount(): Int {
        return mealPlanDao.getSavedCount() // Uses existing DAO method
    }
}